{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p><code>onion_config</code> is a Python package designed for easy configuration management. It supports loading and validating configuration data from environment variables and configuration files in JSON and YAML formats. It is a <code>Pydantic</code> based custom configuration package for Python projects.</p>"},{"location":"#features","title":"\u2728 Features","text":"<ul> <li>Main config based on Pydantic schema - https://pypi.org/project/pydantic</li> <li>Load environment variables - https://pypi.org/project/python-dotenv</li> <li>Load from multiple configs directories</li> <li>Load configs from YAML and JSON files</li> <li>Update the default config with additional configurations (<code>extra_dir</code> directory)</li> <li>Pre-load hook function to modify config data before loading and validation</li> <li>Validate config values with Pydantic validators</li> <li>Config as dictionary or Pydantic model (with type hints)</li> <li>Pre-defined base config schema for common config (<code>BaseConfig</code>)</li> <li>Base for custom config loader (<code>ConfigLoader</code>)</li> <li>Support Pydantic-v1 and Pydantic-v2</li> </ul>"},{"location":"pages/","title":"Pages","text":"<p>All the pages are written in markdown and are located in the <code>docs/pages</code> directory. The pages are automatically generated by the <code>mkdocs</code> tool.</p>"},{"location":"pages/release-notes/","title":"\ud83d\udccc Release Notes","text":""},{"location":"pages/release-notes/#v001-2024-01-01","title":"v0.0.1 (2024-01-01)","text":"<ul> <li>Initial release</li> </ul>"},{"location":"pages/about/","title":"\u2139\ufe0f About","text":"<p>This section contains non-technical information about this project.</p>"},{"location":"pages/about/#pages","title":"Pages","text":"<ul> <li>FAQ</li> <li>Authors</li> <li>Contact</li> <li>License</li> </ul>"},{"location":"pages/about/authors/","title":"\ud83e\uddd9\u200d\u2642\ufe0f Authors","text":"<p>This project is developed by the following authors:</p> <ul> <li>@bybatkhuu - Batkhuu Byambajav</li> </ul>"},{"location":"pages/about/contact/","title":"\ud83d\udcde Contact","text":"<p>You can contact me by email at batkhuu10@gmail.com.</p>"},{"location":"pages/about/faq/","title":"\ud83d\udc4b FAQ","text":"<p>This section contains frequently asked questions about this project.</p>"},{"location":"pages/about/faq/#q1-how-do-i-get-started-with-this-project","title":"Q1: How do I get started with this project?","text":"<p>To get started with this project, follow the instructions in the Getting Started guide.</p>"},{"location":"pages/about/license/","title":"\u00a9\ufe0f License","text":"<p>This project is licensed as the <code>LICENSE.md</code> file for details.</p>"},{"location":"pages/api-docs/","title":"\ud83e\udd13 API Documentation","text":"<p>This section provides information on the API documentation for this project.</p>"},{"location":"pages/api-docs/#pages","title":"Pages","text":"<ul> <li>ConfigLoader</li> <li>Diagrams</li> </ul>"},{"location":"pages/api-docs/ConfigLoader/","title":"ConfigLoader","text":"<p>A core class of <code>onion_config</code> module to use as the main config loader.</p> <p>Attributes:</p> Name Type Description <code>_ENV_FILE_PATH</code> <code>str</code> <p>Default dotenv file path to load. Defaults to '${PWD}/.env'.</p> <code>_CONFIGS_DIR</code> <code>  (str                       </code> <p>Default configs directory. Defaults to '${PWD}/configs'.</p> <code>_PRE_LOAD_HOOK</code> <code>function</code> <p>Default lambda function for <code>pre_load_hook</code>. Defaults to <code>lambda config_data: config_data</code>.</p> <code>config_data</code> <code>   (dict                      </code> <p>Loaded data from config files as a dictionary. Defaults to {}.</p> <code>configs_dirs</code> <code>  (str                       </code> <p>Main configs directories as  to load all config files. Defaults to [ConfigLoader._CONFIGS_DIR]. <code>extra_dir</code> <code>     (str                       </code> <p>Extra configs directory to load extra config files. Defaults to None, but will use the 'ONION_CONFIG_EXTRA_DIR' environment variable if set.</p> <code>env_file_paths</code> <code>str</code> <p>Dotenv file paths as  to load. Defaults to [ConfigLoader._ENV_FILE_PATH]. <code>required_envs</code> <code> (str                       </code> <p>Required environment variables to check. Defaults to [].</p> <code>pre_load_hook</code> <code> (function                  </code> <p>Custom pre-load method, this method will executed before validating <code>config</code>. Defaults to <code>ConfigLoader._PRE_LOAD_HOOK</code>.</p> <code>warn_mode</code> <code>     (WarnEnum                  </code> <p>Warning mode to handle warnings. Defaults to <code>WarnEnum.IGNORE</code>.</p> <p>Methods:</p> Name Description <code>load</code> <p>Load and validate every configs into <code>config</code>.</p> <code>_load_dotenv_files</code> <p>Load all dotenv files from <code>env_file_paths</code> into environment variables.</p> <code>_load_dotenv_file</code> <p>Load each dotenv file into environment variables.</p> <code>_check_required_envs</code> <p>Check required environment variables are exist or not.</p> <code>_load_configs_dirs</code> <p>Load all config files from <code>configs_dirs</code> into <code>config_data</code>.</p> <code>_load_configs_dir</code> <p>Load config files from each config directory into <code>config_data</code>.</p> <code>_load_yaml_file</code> <p>Load each YAML config file into <code>config_data</code>.</p> <code>_load_json_file</code> <p>Load each JSON config file into <code>config_data</code>.</p> <code>_load_extra_dir</code> <p>Load extra config files from <code>extra_dir</code> into <code>config_data</code>.</p> Source code in <code>src/onion_config/_base.py</code> <pre><code>class ConfigLoader:\n    \"\"\"A core class of `onion_config` module to use as the main config loader.\n\n    Attributes:\n        _ENV_FILE_PATH (str                       ): Default dotenv file path to load. Defaults to '${PWD}/.env'.\n        _CONFIGS_DIR   (str                       ): Default configs directory. Defaults to '${PWD}/configs'.\n        _PRE_LOAD_HOOK (function                  ): Default lambda function for `pre_load_hook`. Defaults to `lambda config_data: config_data`.\n\n        config         (Union[BaseConfig,\n                              BaseSettings,\n                              BaseModel          ]): Main config object (based on `config_schema`) for project. Defaults to None.\n        config_schema  (Union[Type[BaseConfig],\n                              Type[BaseSettings],\n                              Type[BaseModel]    ]): Main config schema class to load and validate configs. Defaults to `BaseConfig`.\n        config_data    (dict                      ): Loaded data from config files as a dictionary. Defaults to {}.\n        configs_dirs   (str                       ): Main configs directories as &lt;list&gt; to load all config files. Defaults to [ConfigLoader._CONFIGS_DIR].\n        extra_dir      (str                       ): Extra configs directory to load extra config files. Defaults to None, but will use the 'ONION_CONFIG_EXTRA_DIR' environment variable if set.\n        env_file_paths (str                       ): Dotenv file paths as &lt;list&gt; to load. Defaults to [ConfigLoader._ENV_FILE_PATH].\n        required_envs  (str                       ): Required environment variables to check. Defaults to [].\n        pre_load_hook  (function                  ): Custom pre-load method, this method will executed before validating `config`. Defaults to `ConfigLoader._PRE_LOAD_HOOK`.\n        warn_mode      (WarnEnum                  ): Warning mode to handle warnings. Defaults to `WarnEnum.IGNORE`.\n\n    Methods:\n        load()                : Load and validate every configs into `config`.\n        _load_dotenv_files()  : Load all dotenv files from `env_file_paths` into environment variables.\n        _load_dotenv_file()   : Load each dotenv file into environment variables.\n        _check_required_envs(): Check required environment variables are exist or not.\n        _load_configs_dirs()  : Load all config files from `configs_dirs` into `config_data`.\n        _load_configs_dir()   : Load config files from each config directory into `config_data`.\n        _load_yaml_file()     : Load each YAML config file into `config_data`.\n        _load_json_file()     : Load each JSON config file into `config_data`.\n        _load_extra_dir()     : Load extra config files from `extra_dir` into `config_data`.\n    \"\"\"\n\n    _ENV_FILE_PATH = os.path.join(os.getcwd(), \".env\")\n    _CONFIGS_DIR = os.path.join(os.getcwd(), \"configs\")\n    _PRE_LOAD_HOOK = lambda config_data: config_data\n\n    @validate_call\n    def __init__(\n        self,\n        config_schema: Union[\n            Type[BaseConfig], Type[BaseSettings], Type[BaseModel]\n        ] = BaseConfig,\n        configs_dirs: Union[List[str], str] = _CONFIGS_DIR,\n        env_file_paths: Union[List[str], str] = _ENV_FILE_PATH,\n        required_envs: List[str] = [],\n        pre_load_hook: Callable = _PRE_LOAD_HOOK,\n        extra_dir: Union[str, None] = None,\n        config_data: Dict[str, Any] = {},\n        warn_mode: WarnEnum = WarnEnum.IGNORE,\n        auto_load: bool = False,\n    ):\n        \"\"\"ConfigLoader constructor method.\n\n        Args:\n            config_schema  (Union[Type[BaseConfig],\n                                  Type[BaseSettings],\n                                  Type[BaseModel]    ], optional): Main config schema class to load and validate configs. Defaults to `BaseConfig`.\n            configs_dirs   (Union[List[str], str]     , optional): Main configs directories as &lt;list&gt; or &lt;str&gt; to load all config files. Defaults to `ConfigLoader._CONFIGS_DIR`.\n            env_file_paths (Union[List[str], str]     , optional): Dotenv file paths as &lt;list&gt; or &lt;str&gt; to load. Defaults to `ConfigLoader._ENV_FILE_PATH`.\n            required_envs  (List[str]                 , optional): Required environment variables to check. Defaults to [].\n            pre_load_hook  (function                  , optional): Custom pre-load method, this method will executed before validating `config`. Defaults to `ConfigLoader._PRE_LOAD_HOOK`.\n            extra_dir      (Union[str, None]          , optional): Extra configs directory to load extra config files. Defaults to None.\n            config_data    (dict                      , optional): Base config data as &lt;dict&gt; before everything. Defaults to {}.\n            warn_mode      (WarnEnum                  , optional): Warning mode to handle warnings. Defaults to `WarnEnum.IGNORE`.\n            auto_load      (bool                      , optional): Auto load configs on init or not. Defaults to False.\n        \"\"\"\n\n        self.config_schema = config_schema\n        self.configs_dirs = configs_dirs\n        self.env_file_paths = env_file_paths\n        self.required_envs = required_envs\n        self.pre_load_hook = pre_load_hook\n        if extra_dir:\n            self.extra_dir = extra_dir\n        self.config_data = config_data\n        self.warn_mode = warn_mode\n\n        if auto_load:\n            self.load()\n\n    def load(self) -&gt; Union[BaseConfig, BaseSettings, BaseModel]:\n        \"\"\"Load and validate every configs into `config`.\n        Load order:\n            1.     Load all dotenv files from `env_file_paths` into environment variables.\n            1.1.   Load each dotenv file into environment variables.\n            2.     Check if required environment variables exist or not.\n            3.     Load all config files from `configs_dirs` into `config_data`.\n            3.1.   Load config files from each config directory into `config_data`.\n            3.1.a. Load each YAML config file into `config_data`.\n            3.1.b. Load each JSON config file into `config_data`.\n            4.     Load extra config files from `extra_dir` into `config_data`.\n            5.     Execute `pre_load_hook` method to modify `config_data`.\n            6.     Init `config_schema` with `config_data` into final `config`.\n\n        Raises:\n            Exception: If `pre_load_hook` method failed to execute.\n            Exception: If `config_schema` failed to init.\n\n        Returns:\n            Union[BaseConfig, BaseSettings, BaseModel]: Main config object (based on `config_schema`) for project.\n        \"\"\"\n\n        _message = \"Loading all configs...\"\n        if self.warn_mode == WarnEnum.ALWAYS:\n            logger.info(_message)\n        elif self.warn_mode == WarnEnum.DEBUG:\n            logger.debug(_message)\n\n        self._load_dotenv_files()\n        self._check_required_envs()\n        self._load_configs_dirs()\n        self._load_extra_dir()\n\n        try:\n            # 5. Execute `pre_load_hook` method to modify `config_data`:\n            self.config_data: Dict[str, Any] = self.pre_load_hook(self.config_data)\n        except Exception:\n            logger.critical(\"Failed to execute `pre_load_hook` method:\")\n            raise\n\n        try:\n            # 6. Init `config_schema` with `config_data` into final `config`:\n\n            self.config: Union[\n                BaseConfig, BaseSettings, BaseModel\n            ] = self.config_schema(**self.config_data)\n        except Exception:\n            logger.critical(\"Failed to init `config_schema`:\")\n            raise\n\n        _message = \"Successfully loaded all configs!\"\n        if self.warn_mode == WarnEnum.ALWAYS:\n            logger.success(_message)\n        elif self.warn_mode == WarnEnum.DEBUG:\n            logger.debug(_message)\n\n        return self.config\n\n    def _load_dotenv_files(self):\n        \"\"\"1. Load all dotenv files from `env_file_paths` into environment variables.\"\"\"\n\n        for _env_file_path in self.env_file_paths:\n            self._load_dotenv_file(env_file_path=_env_file_path)\n\n    @validate_call\n    def _load_dotenv_file(self, env_file_path: str):\n        \"\"\"1.1. Load each dotenv file into environment variables.\n\n        Args:\n            env_file_path (str, required): Dotenv file path to load.\n        \"\"\"\n\n        if not os.path.isabs(env_file_path):\n            env_file_path = os.path.join(os.getcwd(), env_file_path)\n\n        if os.path.isfile(env_file_path):\n            load_dotenv(dotenv_path=env_file_path, override=True, encoding=\"utf-8\")\n        else:\n            _message = f\"'{env_file_path}' file is not exist!\"\n            if self.warn_mode == WarnEnum.ERROR:\n                raise FileNotFoundError(_message)\n            elif self.warn_mode == WarnEnum.ALWAYS:\n                logger.warning(_message)\n            elif self.warn_mode == WarnEnum.DEBUG:\n                logger.debug(_message)\n\n    def _check_required_envs(self):\n        \"\"\"2. Check if required environment variables exist or not.\n        If a required environment variable does not exist, raise an exception.\n\n        Raises:\n            KeyError: If a required environment variable does not exist.\n        \"\"\"\n\n        for _env in self.required_envs:\n            try:\n                os.environ[_env]\n            except KeyError:\n                logger.critical(f\"Missing required '{_env}' environment variable.\")\n                raise\n\n    def _load_configs_dirs(self):\n        \"\"\"3. Load all config files from `configs_dirs` into `config_data`.\"\"\"\n\n        for _config_dir in self.configs_dirs:\n            self._load_configs_dir(configs_dir=_config_dir)\n\n    @validate_call\n    def _load_configs_dir(self, configs_dir: str):\n        \"\"\"3.1. Load config files from each config directory into `config_data`.\n\n        Args:\n            configs_dir (str, required): Configs directory to load.\n        \"\"\"\n\n        if not os.path.isabs(configs_dir):\n            configs_dir = os.path.join(os.getcwd(), configs_dir)\n\n        if os.path.isdir(configs_dir):\n            _file_paths = []\n            _file_paths.extend(glob.glob(os.path.join(configs_dir, \"*.yaml\")))\n            _file_paths.extend(glob.glob(os.path.join(configs_dir, \"*.yml\")))\n            _file_paths.extend(glob.glob(os.path.join(configs_dir, \"*.json\")))\n            # _file_paths.extend(glob.glob(os.path.join(configs_dir, \"*.toml\")))\n            _file_paths.sort()\n\n            for _file_path in _file_paths:\n                if _file_path.lower().endswith((\".yml\", \".yaml\")):\n                    self._load_yaml_file(file_path=_file_path)\n                elif _file_path.lower().endswith(\".json\"):\n                    self._load_json_file(file_path=_file_path)\n                # elif _file_path.lower().endswith(\".toml\"):\n                #     self._load_toml_file(file_path=_file_path)\n        else:\n            _message = f\"'{configs_dir}' directory is not exist!\"\n            if self.warn_mode == WarnEnum.ERROR:\n                raise FileNotFoundError(_message)\n            elif self.warn_mode == WarnEnum.ALWAYS:\n                logger.warning(_message)\n            elif self.warn_mode == WarnEnum.DEBUG:\n                logger.debug(_message)\n\n    @validate_call\n    def _load_yaml_file(self, file_path: str):\n        \"\"\"3.1.a. Load each YAML config file into `config_data`.\n\n        Args:\n            file_path (str, required): YAML config file path to load.\n\n        Raises:\n            Exception: If failed to load any YAML config file.\n        \"\"\"\n\n        if os.path.isfile(file_path):\n            try:\n                with open(file_path, \"r\", encoding=\"utf-8\") as _file:\n                    _new_config_dict = yaml.safe_load(_file) or {}\n                    self.config_data = deep_merge(self.config_data, _new_config_dict)\n            except Exception:\n                logger.critical(f\"Failed to load '{file_path}' YAML config file:\")\n                raise\n\n    @validate_call\n    def _load_json_file(self, file_path: str):\n        \"\"\"3.1.b. Load each JSON config file into `config_data`.\n\n        Args:\n            file_path (str, required): JSON config file path to load.\n\n        Raises:\n            Exception: If failed to load any JSON config file.\n        \"\"\"\n\n        if os.path.isfile(file_path):\n            try:\n                with open(file_path, \"r\", encoding=\"utf-8\") as _file:\n                    _new_config_dict = json.load(_file) or {}\n                    self.config_data = deep_merge(self.config_data, _new_config_dict)\n            except Exception:\n                logger.critical(f\"Failed to load '{file_path}' JSON config file:\")\n                raise\n\n    # @validate_call\n    # def _load_toml_file(self, file_path: str):\n    #     \"\"\"3.1.c. Load each TOML config file into `config_data`.\n\n    #     Args:\n    #         file_path (str, required): TOML config file path to load.\n\n    #     Raises:\n    #         Exception: If failed to load any TOML config file.\n    #     \"\"\"\n\n    #     if os.path.isfile(file_path):\n    #         try:\n    #             import toml\n\n    #             with open(file_path, \"r\", encoding=\"utf-8\") as _file:\n    #                 _new_config_dict = toml.load(_file) or {}\n    #                 self.config_data = deep_merge(self.config_data, _new_config_dict)\n    #         except Exception:\n    #             logger.critical(f\"Failed to load '{file_path}' TOML config file:\")\n    #             raise\n\n    def _load_extra_dir(self):\n        \"\"\"4. Load extra config files from `extra_dir` into `config_data`.\"\"\"\n\n        _env_extra_dir = os.getenv(\"ONION_CONFIG_EXTRA_DIR\")\n        if _env_extra_dir:\n            self.extra_dir = _env_extra_dir\n\n        if self.extra_dir:\n            self._load_configs_dir(configs_dir=self.extra_dir)\n\n    ### ATTRIBUTES ###\n\n    ## config ##\n    @property\n    def config(self) -&gt; Union[BaseConfig, BaseSettings, BaseModel, None]:\n        try:\n            return self.__config\n        except AttributeError:\n            return None\n\n    @config.setter\n    def config(self, config: Union[BaseConfig, BaseSettings, BaseModel]):\n        if (\n            (not isinstance(config, BaseConfig))\n            and (not isinstance(config, BaseSettings))\n            and (not isinstance(config, BaseModel))\n        ):\n            raise TypeError(\n                f\"`config` attribute type {type(config)} is invalid, must be a &lt;class 'BaseConfig'&gt; or `pydantic` &lt;class 'BaseSettings'&gt; or &lt;class 'BaseModel'&gt;.\"\n            )\n\n        self.__config = copy.deepcopy(config)\n\n    ## config ##\n\n    ## config_schema ##\n    @property\n    def config_schema(\n        self,\n    ) -&gt; Union[Type[BaseConfig], Type[BaseSettings], Type[BaseModel]]:\n        try:\n            return self.__config_schema\n        except AttributeError:\n            self.__config_schema = BaseConfig\n\n        return self.__config_schema\n\n    @config_schema.setter\n    def config_schema(\n        self,\n        config_schema: Union[Type[BaseConfig], Type[BaseSettings], Type[BaseModel]],\n    ):\n        # Check if config_schema is a class (i.e., an instance of type)\n        if not isinstance(config_schema, type):\n            raise TypeError(\"`config_schema` must be a class, not an instance.\")\n\n        # Check if config_schema is a subclass of BaseConfig, BaseSettings or BaseModel\n        if (\n            (not issubclass(config_schema, BaseConfig))\n            and (not issubclass(config_schema, BaseSettings))\n            and (not issubclass(config_schema, BaseModel))\n        ):\n            _base_class = \"\"\n            if hasattr(config_schema, \"__base__\"):\n                _base_class = config_schema.__base__\n            else:\n                _base_class = type(config_schema)\n\n            raise TypeError(\n                f\"`config_schema` attribute base class {_base_class} is invalid, must be a Type[&lt;class 'BaseConfig'&gt;] or `pydantic` Type[&lt;class 'BaseSettings'&gt;, &lt;class 'BaseModel'&gt;].\"\n            )\n\n        self.__config_schema = config_schema\n\n    ## config_schema ##\n\n    ## config_data ##\n    @property\n    def config_data(self) -&gt; Dict[str, Any]:\n        try:\n            return self.__config_data\n        except AttributeError:\n            self.__config_data = {}\n\n        return self.__config_data\n\n    @config_data.setter\n    def config_data(self, config_data: Dict[str, Any]):\n        if not isinstance(config_data, dict):\n            raise TypeError(\n                f\"`config_data` attribute type {type(config_data)} is invalid, must be a &lt;dict&gt;.\"\n            )\n\n        self.__config_data = copy.deepcopy(config_data)\n\n    ## config_data ##\n\n    ## configs_dirs ##\n    @property\n    def configs_dirs(self) -&gt; List[str]:\n        try:\n            return self.__configs_dirs\n        except AttributeError:\n            self.__configs_dirs = [ConfigLoader._CONFIGS_DIR]\n\n        return self.__configs_dirs\n\n    @configs_dirs.setter\n    def configs_dirs(self, configs_dirs: Union[List[str], str]):\n        if (not isinstance(configs_dirs, str)) and (not isinstance(configs_dirs, list)):\n            raise TypeError(\n                f\"`configs_dirs` attribute type {type(configs_dirs)} is invalid, must be a &lt;list&gt; or &lt;str&gt;!\"\n            )\n\n        if isinstance(configs_dirs, str):\n            configs_dirs = configs_dirs.strip()\n            if configs_dirs == \"\":\n                raise ValueError(\"The `configs_dirs` attribute value is empty!\")\n\n            configs_dirs = [configs_dirs]\n        else:\n            configs_dirs = copy.deepcopy(configs_dirs)\n\n        if not all(isinstance(_val, str) for _val in configs_dirs):\n            raise ValueError(\n                f\"'configs_dirs' attribute value {configs_dirs} is invalid, must be a list of &lt;str&gt;!\"\n            )\n\n        self.__configs_dirs = configs_dirs\n\n    ## configs_dirs ##\n\n    ## extra_dir ##\n    @property\n    def extra_dir(self) -&gt; Union[str, None]:\n        try:\n            return self.__extra_dir\n        except AttributeError:\n            return None\n\n    @extra_dir.setter\n    def extra_dir(self, extra_dir: str):\n        if not isinstance(extra_dir, str):\n            raise TypeError(\n                f\"`extra_dir` attribute type {type(extra_dir)} is invalid, must be a &lt;str&gt;!\"\n            )\n\n        extra_dir = extra_dir.strip()\n        if extra_dir == \"\":\n            raise ValueError(\"The `extra_dir` attribute value is empty!\")\n\n        if not os.path.isabs(extra_dir):\n            extra_dir = os.path.join(os.getcwd(), extra_dir)\n\n        self.__extra_dir = extra_dir\n\n    ## extra_dir ##\n\n    ## env_file_paths ##\n    @property\n    def env_file_paths(self) -&gt; List[str]:\n        try:\n            return self.__env_file_paths\n        except AttributeError:\n            self.__env_file_paths = [ConfigLoader._ENV_FILE_PATH]\n\n        return self.__env_file_paths\n\n    @env_file_paths.setter\n    def env_file_paths(self, env_file_paths: Union[List[str], str]):\n        if (not isinstance(env_file_paths, str)) and (\n            not isinstance(env_file_paths, list)\n        ):\n            raise TypeError(\n                f\"'env_file_paths' attribute type {type(env_file_paths)} is invalid, must be a &lt;list&gt; or &lt;str&gt;!\"\n            )\n\n        if isinstance(env_file_paths, str):\n            env_file_paths = env_file_paths.strip()\n            if env_file_paths == \"\":\n                raise ValueError(\"The `env_file_paths` attribute value is empty!\")\n\n            env_file_paths = [env_file_paths]\n        else:\n            env_file_paths = copy.deepcopy(env_file_paths)\n\n        if not all(isinstance(_val, str) for _val in env_file_paths):\n            raise ValueError(\n                f\"'env_file_paths' attribute value {env_file_paths} is invalid, must be a list of &lt;str&gt;!\"\n            )\n\n        self.__env_file_paths = env_file_paths\n\n    ## env_file_paths ##\n\n    ## required_envs ##\n    @property\n    def required_envs(self) -&gt; List[str]:\n        try:\n            return self.__required_envs\n        except AttributeError:\n            self.__required_envs = []\n\n        return self.__required_envs\n\n    @required_envs.setter\n    def required_envs(self, required_envs: List[str]):\n        if not isinstance(required_envs, list):\n            raise TypeError(\n                f\"'required_envs' attribute type {type(required_envs)} is invalid, must be a &lt;list&gt;!\"\n            )\n\n        if not all(isinstance(_val, str) for _val in required_envs):\n            raise ValueError(\n                f\"'required_envs' attribute value {required_envs} is invalid, must be a list of &lt;str&gt;!\"\n            )\n\n        self.__required_envs = copy.deepcopy(required_envs)\n\n    ## required_envs ##\n\n    ## pre_load_hook ##\n    @property\n    def pre_load_hook(self) -&gt; Callable:\n        try:\n            return self.__pre_load_hook\n        except AttributeError:\n            self.__pre_load_hook = ConfigLoader._PRE_LOAD_HOOK\n\n        return self.__pre_load_hook\n\n    @pre_load_hook.setter\n    def pre_load_hook(self, pre_load_hook: Callable):\n        if not callable(pre_load_hook):\n            raise TypeError(\n                f\"`pre_load_hook` argument type {type(pre_load_hook)} is invalid, should be callable &lt;function&gt;!\"\n            )\n\n        self.__pre_load_hook = pre_load_hook\n\n    ## pre_load_hook ##\n\n    ## warn_mode ##\n    @property\n    def warn_mode(self) -&gt; WarnEnum:\n        try:\n            return self.__warn_mode\n        except AttributeError:\n            return WarnEnum.IGNORE\n\n    @warn_mode.setter\n    def warn_mode(self, warn_mode: Union[WarnEnum, str]):\n        if (not isinstance(warn_mode, WarnEnum)) and (not isinstance(warn_mode, str)):\n            raise TypeError(\n                f\"'warn_mode' attribute type {type(warn_mode)} is invalid, must be a &lt;enum 'WarnEnum'&gt; or &lt;str&gt;!\"\n            )\n\n        if isinstance(warn_mode, str):\n            try:\n                warn_mode = WarnEnum(warn_mode)\n            except ValueError:\n                raise ValueError(\n                    f\"'warn_mode' attribute value '{warn_mode}' is invalid, must be a &lt;enum 'WarnEnum'&gt; or 'ERROR', 'ALWAYS', 'DEBUG', 'IGNORE'!\"\n                )\n\n        self.__warn_mode = warn_mode\n</code></pre>"},{"location":"pages/api-docs/ConfigLoader/#src.onion_config.ConfigLoader.__init__","title":"<code>__init__(config_schema=BaseConfig, configs_dirs=_CONFIGS_DIR, env_file_paths=_ENV_FILE_PATH, required_envs=[], pre_load_hook=_PRE_LOAD_HOOK, extra_dir=None, config_data={}, warn_mode=WarnEnum.IGNORE, auto_load=False)</code>","text":"<p>ConfigLoader constructor method.</p> <p>Parameters:</p> Name Type Description Default <code>configs_dirs</code> <code>  (Union[List[str], str]     </code> <p>Main configs directories as  or  to load all config files. Defaults to <code>ConfigLoader._CONFIGS_DIR</code>. <code>_CONFIGS_DIR</code> <code>env_file_paths</code> <code>Union[List[str], str]</code> <p>Dotenv file paths as  or  to load. Defaults to <code>ConfigLoader._ENV_FILE_PATH</code>. <code>_ENV_FILE_PATH</code> <code>required_envs</code> <code> (List[str]                 </code> <p>Required environment variables to check. Defaults to [].</p> <code>[]</code> <code>pre_load_hook</code> <code> (function                  </code> <p>Custom pre-load method, this method will executed before validating <code>config</code>. Defaults to <code>ConfigLoader._PRE_LOAD_HOOK</code>.</p> <code>_PRE_LOAD_HOOK</code> <code>extra_dir</code> <code>     (Union[str, None]          </code> <p>Extra configs directory to load extra config files. Defaults to None.</p> <code>None</code> <code>config_data</code> <code>   (dict                      </code> <p>Base config data as  before everything. Defaults to {}. <code>{}</code> <code>warn_mode</code> <code>     (WarnEnum                  </code> <p>Warning mode to handle warnings. Defaults to <code>WarnEnum.IGNORE</code>.</p> <code>IGNORE</code> <code>auto_load</code> <code>     (bool                      </code> <p>Auto load configs on init or not. Defaults to False.</p> <code>False</code> Source code in <code>src/onion_config/_base.py</code> <pre><code>@validate_call\ndef __init__(\n    self,\n    config_schema: Union[\n        Type[BaseConfig], Type[BaseSettings], Type[BaseModel]\n    ] = BaseConfig,\n    configs_dirs: Union[List[str], str] = _CONFIGS_DIR,\n    env_file_paths: Union[List[str], str] = _ENV_FILE_PATH,\n    required_envs: List[str] = [],\n    pre_load_hook: Callable = _PRE_LOAD_HOOK,\n    extra_dir: Union[str, None] = None,\n    config_data: Dict[str, Any] = {},\n    warn_mode: WarnEnum = WarnEnum.IGNORE,\n    auto_load: bool = False,\n):\n    \"\"\"ConfigLoader constructor method.\n\n    Args:\n        config_schema  (Union[Type[BaseConfig],\n                              Type[BaseSettings],\n                              Type[BaseModel]    ], optional): Main config schema class to load and validate configs. Defaults to `BaseConfig`.\n        configs_dirs   (Union[List[str], str]     , optional): Main configs directories as &lt;list&gt; or &lt;str&gt; to load all config files. Defaults to `ConfigLoader._CONFIGS_DIR`.\n        env_file_paths (Union[List[str], str]     , optional): Dotenv file paths as &lt;list&gt; or &lt;str&gt; to load. Defaults to `ConfigLoader._ENV_FILE_PATH`.\n        required_envs  (List[str]                 , optional): Required environment variables to check. Defaults to [].\n        pre_load_hook  (function                  , optional): Custom pre-load method, this method will executed before validating `config`. Defaults to `ConfigLoader._PRE_LOAD_HOOK`.\n        extra_dir      (Union[str, None]          , optional): Extra configs directory to load extra config files. Defaults to None.\n        config_data    (dict                      , optional): Base config data as &lt;dict&gt; before everything. Defaults to {}.\n        warn_mode      (WarnEnum                  , optional): Warning mode to handle warnings. Defaults to `WarnEnum.IGNORE`.\n        auto_load      (bool                      , optional): Auto load configs on init or not. Defaults to False.\n    \"\"\"\n\n    self.config_schema = config_schema\n    self.configs_dirs = configs_dirs\n    self.env_file_paths = env_file_paths\n    self.required_envs = required_envs\n    self.pre_load_hook = pre_load_hook\n    if extra_dir:\n        self.extra_dir = extra_dir\n    self.config_data = config_data\n    self.warn_mode = warn_mode\n\n    if auto_load:\n        self.load()\n</code></pre>"},{"location":"pages/api-docs/ConfigLoader/#src.onion_config.ConfigLoader.load","title":"<code>load()</code>","text":"<p>Load and validate every configs into <code>config</code>. Load order:     1.     Load all dotenv files from <code>env_file_paths</code> into environment variables.     1.1.   Load each dotenv file into environment variables.     2.     Check if required environment variables exist or not.     3.     Load all config files from <code>configs_dirs</code> into <code>config_data</code>.     3.1.   Load config files from each config directory into <code>config_data</code>.     3.1.a. Load each YAML config file into <code>config_data</code>.     3.1.b. Load each JSON config file into <code>config_data</code>.     4.     Load extra config files from <code>extra_dir</code> into <code>config_data</code>.     5.     Execute <code>pre_load_hook</code> method to modify <code>config_data</code>.     6.     Init <code>config_schema</code> with <code>config_data</code> into final <code>config</code>.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If <code>pre_load_hook</code> method failed to execute.</p> <code>Exception</code> <p>If <code>config_schema</code> failed to init.</p> <p>Returns:</p> Type Description <code>Union[BaseConfig, BaseSettings, BaseModel]</code> <p>Union[BaseConfig, BaseSettings, BaseModel]: Main config object (based on <code>config_schema</code>) for project.</p> Source code in <code>src/onion_config/_base.py</code> <pre><code>def load(self) -&gt; Union[BaseConfig, BaseSettings, BaseModel]:\n    \"\"\"Load and validate every configs into `config`.\n    Load order:\n        1.     Load all dotenv files from `env_file_paths` into environment variables.\n        1.1.   Load each dotenv file into environment variables.\n        2.     Check if required environment variables exist or not.\n        3.     Load all config files from `configs_dirs` into `config_data`.\n        3.1.   Load config files from each config directory into `config_data`.\n        3.1.a. Load each YAML config file into `config_data`.\n        3.1.b. Load each JSON config file into `config_data`.\n        4.     Load extra config files from `extra_dir` into `config_data`.\n        5.     Execute `pre_load_hook` method to modify `config_data`.\n        6.     Init `config_schema` with `config_data` into final `config`.\n\n    Raises:\n        Exception: If `pre_load_hook` method failed to execute.\n        Exception: If `config_schema` failed to init.\n\n    Returns:\n        Union[BaseConfig, BaseSettings, BaseModel]: Main config object (based on `config_schema`) for project.\n    \"\"\"\n\n    _message = \"Loading all configs...\"\n    if self.warn_mode == WarnEnum.ALWAYS:\n        logger.info(_message)\n    elif self.warn_mode == WarnEnum.DEBUG:\n        logger.debug(_message)\n\n    self._load_dotenv_files()\n    self._check_required_envs()\n    self._load_configs_dirs()\n    self._load_extra_dir()\n\n    try:\n        # 5. Execute `pre_load_hook` method to modify `config_data`:\n        self.config_data: Dict[str, Any] = self.pre_load_hook(self.config_data)\n    except Exception:\n        logger.critical(\"Failed to execute `pre_load_hook` method:\")\n        raise\n\n    try:\n        # 6. Init `config_schema` with `config_data` into final `config`:\n\n        self.config: Union[\n            BaseConfig, BaseSettings, BaseModel\n        ] = self.config_schema(**self.config_data)\n    except Exception:\n        logger.critical(\"Failed to init `config_schema`:\")\n        raise\n\n    _message = \"Successfully loaded all configs!\"\n    if self.warn_mode == WarnEnum.ALWAYS:\n        logger.success(_message)\n    elif self.warn_mode == WarnEnum.DEBUG:\n        logger.debug(_message)\n\n    return self.config\n</code></pre>"},{"location":"pages/api-docs/diagrams/","title":"\ud83d\uddbc\ufe0f Diagrams","text":"<p>This page contains diagrams that illustrate the architecture of the module.</p>"},{"location":"pages/api-docs/diagrams/#class","title":"Class","text":""},{"location":"pages/api-docs/diagrams/#package","title":"Package","text":""},{"location":"pages/api-docs/diagrams/#call-graph","title":"Call Graph","text":""},{"location":"pages/dev/","title":"\ud83d\udcbb Development","text":"<p>This section provides information on how to develop or contribute to this project.</p>"},{"location":"pages/dev/#pages","title":"Pages","text":"<ul> <li>Test</li> <li>Build</li> <li>Docs</li> <li>CI/CD</li> <li>Scripts<ul> <li>base.sh</li> <li>clean.sh</li> <li>get-version.sh</li> <li>test.sh</li> <li>bump-version.sh</li> <li>build.sh</li> <li>changelog.sh</li> <li>docs.sh</li> <li>diagrams.sh</li> </ul> </li> <li>File Structure</li> <li>Sitemap</li> <li>Related Projects</li> <li>Contributing</li> <li>Roadmap</li> </ul>"},{"location":"pages/dev/build/","title":"\ud83c\udfd7\ufe0f Build Python Package","text":"<p>To build the python package, run the following command:</p> <pre><code># Install python build dependencies:\npip install -r ./requirements/requirements.build.txt\n\n# Build python package:\npython -m build\n# Or use the build script:\n./scripts/build.sh\n</code></pre>"},{"location":"pages/dev/build/#build","title":"Build","text":"<pre><code># Install python build:\npip install -U build\n\n# Build help:\npython -m build --help\n</code></pre>"},{"location":"pages/dev/build/#references","title":"References","text":"<ul> <li>Python Packaging User Guide</li> <li>Packaging Python Projects</li> <li>Writing your <code>pyproject.toml</code></li> <li>Setuptools Documentation</li> <li>Blogs:<ul> <li>Python Packaging Best Practices</li> <li>Generic Folder Structure for your Machine Learning Projects</li> <li>How to Upload your Python Package to PyPI</li> </ul> </li> </ul>"},{"location":"pages/dev/cicd/","title":"\ud83d\udc77 CI/CD","text":"<p>This section provides information on how to setup and configure CI/CD pipelines for this project.</p>"},{"location":"pages/dev/cicd/#github-actions","title":"GitHub Actions","text":""},{"location":"pages/dev/cicd/#references","title":"References","text":"<ul> <li>GitHub Actions Documentation</li> <li>GitHub Actions Marketplace</li> </ul>"},{"location":"pages/dev/contributing/","title":"\ud83e\udd1d Contributing","text":"<p>This project is encourages contributions!</p>"},{"location":"pages/dev/docs/","title":"\ud83d\udcdd Docs","text":"<p>To build the documentation, run the following command:</p> <pre><code># Install python documentation dependencies:\npip install -r ./requirements/requirements.docs.txt\n\n# Serve documentation locally (for development):\nmkdocs serve\n# Or use the docs script:\n./scripts/docs.sh\n\n# Or build documentation:\nmkdocs build\n# Or use the docs script:\n./scripts/docs.sh -b\n</code></pre>"},{"location":"pages/dev/docs/#diagrams","title":"Diagrams","text":"<p>Prerequisites:</p> <ul> <li>Install Graphviz</li> </ul> <p>To generate diagrams, run the following command:</p> <pre><code># Install python documentation dependencies:\npip install -r ./requirements/requirements.docs.txt\n\n# Generate diagrams:\n./scripts/diagrams.sh\n</code></pre>"},{"location":"pages/dev/docs/#mkdocs-material","title":"MkDocs Material","text":""},{"location":"pages/dev/docs/#installation","title":"Installation","text":"<pre><code># Install mkdocs-material and mkdocstrings:\npip install -U mkdocs-material mkdocstrings[python]\n</code></pre>"},{"location":"pages/dev/docs/#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"pages/dev/docs/#docs-layout","title":"Docs layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"pages/dev/docs/#references","title":"References","text":"<ul> <li>MkDocs Documentation</li> <li>MkDocs Material Documentation</li> <li>mkdocstrings Documentation</li> </ul>"},{"location":"pages/dev/file-structure/","title":"\ud83d\udcc2 File Structure","text":"<pre><code>project/\n\u251c\u2500\u2500 .github/                # GitHub specific files\n|   \u251c\u2500\u2500 workflows/              # GitHub actions as workflows\n|   \u2514\u2500\u2500 release.yml             # Categories and labels for release notes\n\u251c\u2500\u2500 .vscode/                # VSCode specific files\n|   \u251c\u2500\u2500 extensions.json         # Recommended extensions for the workspace\n|   \u2514\u2500\u2500 settings.json           # Common VSCode settings for the workspace (e.g. formatting, linting, etc...)\n\u251c\u2500\u2500 docs/                   # Documentation of this project\n|   \u251c\u2500\u2500 assets/                 # Any assets (images, audios, videos, js, css, html, etc...) used for the documentation\n|   \u251c\u2500\u2500 diagrams/               # Diagrams related to this project\n|   \u251c\u2500\u2500 pages/                  # MkDocs pages - markdown files\n|   \u251c\u2500\u2500 references/             # References related to this project (papers, articles, manuals, etc...)\n|   \u2514\u2500\u2500 reports/                # Reports based on results of this project\n\u251c\u2500\u2500 examples/               # Example source codes of this project\n\u251c\u2500\u2500 requirements/           # Python dependency requirements for different environments\n\u251c\u2500\u2500 scripts/                # Helpful scripts to automate tasks or assist in the development process\n\u251c\u2500\u2500 onion_config/            # Main CODEBASE of this project as a python module\n|   \u251c\u2500\u2500 modules/                # External modules for this project\n|   |   \u251c\u2500\u2500 module_1/\n|   |   \u251c\u2500\u2500 module_2/\n|   |   \u2514\u2500\u2500 .../\n|   \u251c\u2500\u2500 __init__.py             # Initialize the module to be used as a package\n|   \u251c\u2500\u2500 __version__.py          # Version of the module (should be updated and used with each release)\n|   \u2514\u2500\u2500 ...                     # Other main python files of this module\n\u251c\u2500\u2500 templates/              # Template files (if any, e.g. config files, etc...) used in this project\n\u251c\u2500\u2500 tests/                  # Tests for this project\n|   \u251c\u2500\u2500 __init__.py             # Initialize the test module\n|   \u251c\u2500\u2500 conftest.py             # Presets for pytest (e.g. fixtures, plugins, pre/post test hooks, etc...)\n|   \u251c\u2500\u2500 test_1.py               # Test case files\n|   \u251c\u2500\u2500 test_2.py\n|   \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 __init__.py             # Initialize the whole project as a python module to import from other modules\n\u251c\u2500\u2500 .editorconfig           # Editor configuration for consistent coding styles for different editors\n\u251c\u2500\u2500 .env.example            # Example environment variables file\n\u251c\u2500\u2500 .gitignore              # Files and directories to be ignored by git (e.g. data, models, results, etc...)\n\u251c\u2500\u2500 .markdownlint.json      # Markdown linting rules\n\u251c\u2500\u2500 .pre-commit-config.yaml # Pre-commit configuration file\n\u251c\u2500\u2500 CHANGELOG.md            # List of changes for each version of the project\n\u251c\u2500\u2500 environment.yml         # Conda environment file\n\u251c\u2500\u2500 LICENSE.txt             # License file for this project\n\u251c\u2500\u2500 Makefile                # Makefile for common commands and automation\n\u251c\u2500\u2500 MANIFEST.in             # Manifest file for setuptools (to include/exclude files in the source distribution)\n\u251c\u2500\u2500 mkdocs.yml              # MkDocs configuration file\n\u251c\u2500\u2500 pyproject.toml          # PEP 518 configuration file for python packaging\n\u251c\u2500\u2500 pytest.ini              # Pytest configuration file\n\u251c\u2500\u2500 README.md               # Main README file for this project\n\u251c\u2500\u2500 requirements.txt        # Main python dependency requirements for this project\n\u251c\u2500\u2500 setup.cfg               # Configuration for setuptools\n\u2514\u2500\u2500 setup.py                # Setup script for setuptools (for backward compatibility)\n</code></pre>"},{"location":"pages/dev/related-projects/","title":"\ud83d\uddc2 Related Projects","text":"<p>This section lists related projects or sub-module projects that are part of this project.</p>"},{"location":"pages/dev/roadmap/","title":"\ud83d\udee4 Roadmap","text":"<p>This project is still in its early stages of development.</p> <p>The following is a list of features that are planned for future releases:</p>"},{"location":"pages/dev/sitemap/","title":"\ud83d\uddfa\ufe0f Sitemap","text":"<ul> <li>Home</li> <li>Getting Started<ul> <li>Prerequisites</li> <li>Installation</li> <li>Configuration</li> <li>Examples</li> <li>Error Codes</li> </ul> </li> <li>API Documentation<ul> <li>ConfigLoader</li> <li>Diagrams</li> </ul> </li> <li>Development<ul> <li>Test</li> <li>Build</li> <li>Docs</li> <li>CI/CD</li> <li>Scripts<ul> <li>base.sh</li> <li>clean.sh</li> <li>get-version.sh</li> <li>test.sh</li> <li>bump-version.sh</li> <li>build.sh</li> <li>changelog.sh</li> <li>docs.sh</li> <li>diagrams.sh</li> </ul> </li> <li>File Structure</li> <li>Sitemap</li> <li>Related Projects</li> <li>Contributing</li> <li>Roadmap</li> </ul> </li> <li>Release Notes</li> <li>About<ul> <li>FAQ</li> <li>Authors</li> <li>Contact</li> <li>License</li> </ul> </li> </ul>"},{"location":"pages/dev/test/","title":"\ud83e\uddea Test","text":"<p>To run tests, run the following command:</p> <pre><code># Install core dependencies:\npip install -r ./requirements/requirements.core.txt\n\n# Pydantic-v1:\npip install -r ./requirements/requirements.pydantic-v1.txt\n# Pydantic-v2:\npip install -r ./requirements/requirements.pydantic-settings.txt\n\n# Install python test dependencies:\npip install -r ./requirements.test.txt\n\n# Run tests:\npython -m pytest -sv -o log_cli=true\n# Or use the test script:\n./scripts/test.sh -l -v -c\n</code></pre>"},{"location":"pages/dev/test/#pytest","title":"Pytest","text":"<pre><code># Install pytest:\npip install -U pytest pytest-cov pytest-xdist pytest-benchmark\n\n# Run tests:\npython -m pytest\n\n# Pytest help:\npython -m pytest --help\n</code></pre>"},{"location":"pages/dev/test/#references","title":"References","text":"<ul> <li>Pytest Documentation</li> <li>Pytest Getting Started</li> <li>Pytest Fixtures</li> <li>Blogs:<ul> <li>https://docs.pytest.org/en/latest/goodpractices.html</li> <li>https://emimartin.me/pytest_best_practices</li> <li>https://esaezgil.com/post/unittesting_pitfalls</li> <li>https://pytest-with-eric.com/mocking/pytest-common-mocking-problems</li> </ul> </li> </ul>"},{"location":"pages/dev/scripts/","title":"\ud83d\udd28 Scripts","text":"<p>This document provides an overview and usage instructions for the following scripts in this project:</p> <ul> <li><code>base.sh</code></li> <li><code>clean.sh</code></li> <li><code>get-version.sh</code></li> <li><code>test.sh</code></li> <li><code>bump-version.sh</code></li> <li><code>build.sh</code></li> <li><code>changelog.sh</code></li> <li><code>docs.sh</code></li> <li><code>diagrams.sh</code></li> </ul> <p>All the scripts are located in the <code>scripts</code> directory:</p> <pre><code>scripts/\n\u251c\u2500\u2500 base.sh\n\u251c\u2500\u2500 build.sh\n\u251c\u2500\u2500 bump-version.sh\n\u251c\u2500\u2500 changelog.sh\n\u251c\u2500\u2500 clean.sh\n\u251c\u2500\u2500 diagrams.sh\n\u251c\u2500\u2500 docs.sh\n\u251c\u2500\u2500 get-version.sh\n\u2514\u2500\u2500 test.sh\n</code></pre> <p>These scripts are designed to be used in a Linux or macOS environment. They may work in a Windows environment with the appropriate tools installed, but this is not guaranteed.</p>"},{"location":"pages/dev/scripts/1.base/","title":"\ud83c\udfe0 base.sh","text":"<p>This is a base script used to define common utility functions for other scripts in the project.</p> <p>It contains the following key features:</p> <ul> <li>Date format definition: Defines a date format that is used throughout the scripts.</li> <li>Colour codes: Sets up color codes for console logging if the terminal is recognized as an xterm.</li> <li>Logging functions: Includes <code>echoError</code>, <code>echoWarn</code>, <code>echoInfo</code>, and <code>echoOk</code> which log messages to the console with a timestamp, color-coded based on their severity (error, warning, information, success respectively).</li> <li>Existence checks: Implements the <code>exitIfNotExists</code> and <code>exitIfNoGit</code> functions which check for the existence of a file and the Git software, respectively. They log an error and terminate the script with an appropriate exit code if the check fails.</li> </ul>"},{"location":"pages/dev/scripts/2.clean/","title":"\ud83e\uddf9 clean.sh","text":"<p>This script is designed to clean up the build environment by removing artifacts and other temporary or unwanted files and directories.</p> <p>The script performs the following operations:</p> <ul> <li>Loading base script: Includes the <code>base.sh</code> script to gain access to its utility functions and environment variables.</li> <li>Delete system files: Finds and deletes all <code>.DS_Store</code> and <code>.Thumbs.db</code> files in the project directory and its subdirectories.</li> <li>Delete cache directories: Finds and deletes all <code>__pycache__</code> directories in the project directory and its subdirectories.</li> <li>Delete project-related directories: Removes directories created during the test and build process or by tools used in the project, such as <code>.benchmarks</code>, <code>.pytest_cache</code>, <code>build</code>, and <code>dist</code> directories.</li> <li>Delete <code>.coverage</code> file: Removes the <code>.coverage</code> file that's created when coverage information is collected for the project.</li> </ul> <p>Usage:</p> <p>To execute the clean script, simply run the following command in the terminal:</p> <pre><code>./clean.sh [-a|--all]\n</code></pre> <p>Examples:</p> <ul> <li>To clean just non-essential files: <code>./clean.sh</code></li> <li>To clean all files: <code>./clean.sh -a</code></li> </ul> <p>This will clean up the project directory, removing any unnecessary files and directories and ensuring a clean environment for a fresh build.</p>"},{"location":"pages/dev/scripts/3.get-version/","title":"\ud83d\udd0d get-version.sh","text":"<p>This script is used to retrieve the current version of the application from a specified version file.</p> <p>The script performs the following operations:</p> <ul> <li><code>VERSION_FILE_PATH</code> is either loaded from the environment or, if it's not present in the environment, it defaults to <code>src/onion_config/__version__.py</code>.</li> <li>It first checks if the <code>VERSION_FILE_PATH</code> variable is not empty and if the file exists. If these conditions are met, it retrieves the value of <code>__version__</code> from the file by using <code>grep</code>, <code>awk</code>, and <code>tr</code> commands. The <code>grep</code> command filters the line containing <code>__version__ =</code> , the <code>awk</code> command splits the line into two parts at <code>=</code>, and the <code>tr</code> command removes the quotes around the version. If these operations fail, it exits the script with status code <code>2</code>.</li> <li>If the <code>VERSION_FILE_PATH</code> variable is empty or the file does not exist, it sets the current version to <code>0.0.0</code>.</li> <li>Finally, it echoes the current version to the console.</li> </ul> <p>Usage:</p> <p>To execute the get version script, simply run the following command in the terminal:</p> <pre><code>./get-version.sh\n</code></pre> <p>This script can be used to conveniently fetch the version. It is used by the <code>bump-version.sh</code> script to retrieve the current version before incrementing it.</p>"},{"location":"pages/dev/scripts/4.test/","title":"\ud83e\uddea test.sh","text":"<p>This script is used to run the pytest tests for the project.</p> <p>The script performs the following operations:</p> <ul> <li>Loading base script: Includes the <code>base.sh</code> script to gain access to its utility functions and environment variables.</li> <li>Running pytest: Runs the pytest tests for the project.</li> <li>Logging: If the <code>-l</code> or <code>--log</code> option is provided, the script will log the output of the pytest tests to console.</li> <li>Coverage: If the <code>-c</code> or <code>--cov</code> option is provided, the script will run the pytest tests with coverage.</li> <li>Verbose: If the <code>-v</code> or <code>--verbose</code> option is provided, the script will run the pytest tests with verbose error outputs.</li> </ul> <p>Usage:</p> <p>To execute the test script, simply run the following command in the terminal:</p> <pre><code>./test.sh [-l|--log] [-c|--cov] [-v|--verbose]\n</code></pre> <p>Examples:</p> <ul> <li>To test: <code>./test.sh</code></li> <li>To test with logging: <code>./test.sh -l</code></li> <li>To test with coverage: <code>./test.sh -c</code></li> <li>To test with verbose: <code>./test.sh -v</code></li> <li>To test with logging, coverage and verbose: <code>./test.sh -l -c -v</code></li> </ul> <p>This script will run the pytest tests for the project. It can also be used to run the tests with logging, coverage, and verbose options.</p>"},{"location":"pages/dev/scripts/4.test/#references","title":"References","text":"<ul> <li>https://docs.pytest.org</li> </ul>"},{"location":"pages/dev/scripts/5.bump-version/","title":"\ud83c\udff7 bump-version.sh","text":"<p>This script is used to manage the versioning of the project. It allows you to increment the major, minor, or patch part of the version, as per Semantic Versioning rules.</p> <p>The script carries out the following operations:</p> <ul> <li>Loading base script: It sources the <code>base.sh</code> script, leveraging the utility functions defined there.</li> <li>Loading environment variables: If a <code>.env</code> file is present in the root directory, the script loads the environment variables from this file.</li> <li>Sets variables: Sets the <code>VERSION_FILE_PATH</code> and other variables. The <code>VERSION_FILE_PATH</code> variable is either loaded from the environment or defaults to <code>src/onion_config/__version__.py</code>.</li> <li>Parses input arguments: It parses the <code>-b</code> or <code>--bump-type</code> argument for the type of version bump (<code>major</code>, <code>minor</code>, or <code>patch</code>) and <code>-p</code> or <code>--push-tag</code> to decide whether to push the tag to the Git repository or not.</li> <li>Checks and increments the version: It uses <code>get-version.sh</code> to extract the current version from the file specified by <code>VERSION_FILE_PATH</code>. Based on the bump type, it increments the appropriate part of the version and writes the new version back to the file.</li> <li>Commits and tags: If the <code>-p</code> or <code>--push-tag</code> flag was provided, it adds and commits the changes, pushes the changes, creates a new tag with the new version, and pushes the tag to the Git repository. It will prevent the operation if the tag already exists.</li> </ul> <p>Usage:</p> <p>To execute the bump version script, run the following command in the terminal:</p> <pre><code>./bump-version.sh -b=&lt;bump_type&gt; -p\n</code></pre> <p>Replace <code>&lt;bump_type&gt;</code> with either <code>major</code>, <code>minor</code>, or <code>patch</code> to indicate which part of the version to increment. The <code>-p</code> or <code>--push-tag</code> flag tells the script to commit the changes and push the tag to the Git repository.</p> <p>Examples:</p> <p>To bump the <code>minor</code> version and push the new tag, run:</p> <pre><code>./bump-version.sh -b=minor -p\n</code></pre> <p>This script streamlines the versioning process, reducing the chances of errors and ensuring consistency in versioning.</p>"},{"location":"pages/dev/scripts/5.bump-version/#references","title":"References","text":"<ul> <li>https://semver.org</li> </ul>"},{"location":"pages/dev/scripts/6.build/","title":"\ud83c\udfd7\ufe0f build.sh","text":"<p>This script is used to build a Python project and optionally run tests and publish the package. It also includes a cleaning operation to clear the build directories.</p> <p>This script has the following key features:</p> <ul> <li>Loading base script: Includes the <code>base.sh</code> script to gain access to its utility functions.</li> <li>Checking for required tools: It verifies if Python and the build package are installed on the system. If tests are not disabled, it also checks if pytest is installed. If uploading is enabled, it checks for the presence of Twine.</li> <li>Command-line argument parsing: It parses <code>-c</code> or <code>--disable-clean</code> to disable cleaning the build directories, <code>-t</code> or <code>--test</code> to enable running tests, <code>-u</code> or <code>--upload</code> to enable publishing the package, and <code>-p</code> or <code>--production</code> to switch the package repository from staging (default) to production.</li> <li>Clean operation: Cleans the build directories before and after building (if enabled). If <code>-c</code> or <code>--disable-clean</code> is passed, the script will not clean the build directories.</li> <li>Testing operation: Runs pytest tests if enabled by <code>-t</code> or <code>--test</code> flag.</li> <li>Build operation: Builds a Python package using the Python build package.</li> <li>Publishing operation: Publishes the built package to a PyPi repository using Twine if the <code>-u</code> or <code>--upload</code> flag is passed. Defaults to the TestPyPi (staging) repository, but can be switched to the production (PyPi) repository using the <code>-p</code> or <code>--production</code> flag.</li> </ul> <p>Usage:</p> <p>To execute the build script with the different flags, use the following commands:</p> <pre><code>./build.sh [-c|--disable-clean] [-t|--test] [-u|--upload] [-p|--production]\n</code></pre> <p>Examples:</p> <ul> <li>To build without cleaning: <code>./build.sh -c</code></li> <li>To build with running tests: <code>./build.sh -t</code></li> <li>To build and publish to the staging repository: <code>./build.sh -u</code></li> <li>To build and publish to the production repository: <code>./build.sh -u -p</code></li> </ul> <p>This script is particularly beneficial for developers, streamlining the build, testing, and publishing process. It provides a one-stop solution for all the build needs of a Python project, reducing chances of errors and ensuring consistency.</p>"},{"location":"pages/dev/scripts/7.changelog/","title":"\ud83d\udccc changelog.sh","text":"<p>This script automates the generation and updating of a <code>CHANGELOG.md</code> file using release information fetched from GitHub. It facilitates updating the changelog based on the latest release, and optionally commits and pushes the changes to the Git repository if specified.</p> <p>The script carries out the following operations:</p> <ul> <li>Load base script: Sources the <code>base.sh</code> script from the <code>scripts</code> directory to leverage utility functions.</li> <li>Load environment variables: Loads environment variables from a <code>.env</code> file if it exists in the project root, which may override default values.</li> <li>GitHub CLI check: Ensures that the GitHub CLI (<code>gh</code>) is installed and authenticated; if not, it prompts the user to log in.</li> <li>Variables Setup: <code>CHANGELOG_FILE_PATH</code> specifies the path of the changelog file, defaulting to <code>CHANGELOG.md</code>.</li> <li>Input Parsing:<ul> <li>Flags:<ul> <li><code>-c</code> or <code>--commit</code>: Indicates whether to commit the changelog updates.</li> <li><code>-p</code> or <code>--push</code>: Indicates whether to push the changelog updates after committing.</li> </ul> </li> </ul> </li> <li>Changelog Update:<ul> <li>Release Tag and Notes: Fetches the latest release tag and release notes using <code>gh release view</code>.</li> <li>File Update: Adds or updates the changelog header, appending a new section for the latest release with its tag, release date, and notes.</li> <li>File Commit and Push (optional):<ul> <li>Commits the changelog updates to the Git repository if <code>-c</code> is provided.</li> <li>Pushes the changes if <code>-p</code> is also provided.</li> </ul> </li> </ul> </li> </ul>"},{"location":"pages/dev/scripts/7.changelog/#usage","title":"Usage","text":"<p>To execute <code>changelog.sh</code>, run:</p> <pre><code>./changelog.sh -c -p\n</code></pre>"},{"location":"pages/dev/scripts/8.docs/","title":"\ud83d\udcdd docs.sh","text":"<p>This script is used to manage the documentation for the project, providing options to either serve a local documentation server or build the documentation as static HTML files.</p> <p>The script performs the following operations:</p> <ul> <li>Loading base script: Includes the <code>base.sh</code> script to gain access to its utility functions and environment variables.</li> <li>Serving documentation: If no flags are set, runs <code>mkdocs serve</code> to start a local documentation server for live preview.</li> <li>Building documentation: If the <code>-b</code> or <code>--build</code> flag is set, the script builds the documentation as static HTML files using <code>mkdocs build</code>, placing the output in the <code>site</code> directory.</li> <li>Publishing documentation: If the <code>-p</code> or <code>--publish</code> flag is set, the script can be extended to publish the documentation to GitHub Pages.</li> </ul> <p>Usage:</p> <p>To execute the documentation script, use the following command in the terminal:</p> <pre><code>./docs.sh [-b|--build] [-p|--publish]\n</code></pre> <p>Examples:</p> <ul> <li>To serve the documentation: <code>./docs.sh</code></li> <li>To build the documentation: <code>./docs.sh -b</code></li> <li>To publish the documentation: <code>./docs.sh -p</code></li> </ul>"},{"location":"pages/dev/scripts/9.diagrams/","title":"\ud83d\uddbc\ufe0f diagrams.sh","text":"<p>This script generates UML diagrams for a specified Python module using <code>pyreverse</code> and <code>code2flow</code>. It checks for dependencies, loads environment variables, sets directories, and processes command-line arguments for customization of module names, directories, and output locations.</p>"},{"location":"pages/dev/scripts/9.diagrams/#overview","title":"Overview","text":"<p>The script performs the following operations:</p> <ul> <li> <p>Base Setup: Identifies the project and script directories, sources the <code>base.sh</code> script for utility functions, and loads environment variables from a <code>.env</code> file if it exists.</p> </li> <li> <p>Dependency Checks: Verifies the presence of required tools:</p> <ul> <li><code>graphviz</code> for <code>.dot</code> file handling.</li> <li><code>python</code> for running Python-based commands.</li> <li><code>pylint</code> (with <code>pyreverse</code>) for generating UML diagrams.</li> <li><code>code2flow</code> for creating flowcharts.</li> </ul> </li> <li> <p>Environment Variable Setup: Sets default values for module name, module directory, and output directory (<code>MODULE_NAME</code>, <code>MODULE_DIR</code>, <code>OUTPUT_DIR</code>). These can be customized via environment variables or command-line arguments.</p> </li> <li> <p>Argument Parsing: Parses optional arguments to allow customization:</p> <ul> <li><code>-m</code> or <code>--module-name</code> to specify the module name.</li> <li><code>-d</code> or <code>--module-dir</code> to specify the module directory.</li> <li><code>-o</code> or <code>--output-dir</code> to specify the output directory.</li> </ul> </li> <li> <p>Directory Creation: Creates subdirectories within the output directory for organizing different types of UML and flowchart outputs:</p> <ul> <li><code>classes</code> for class diagrams.</li> <li><code>packages</code> for package diagrams.</li> <li><code>flowcharts</code> for code flowcharts.</li> </ul> </li> <li> <p>Diagram Generation: Runs <code>pyreverse</code> to create UML diagrams in multiple formats (<code>html</code>, <code>pdf</code>, <code>png</code>, and <code>svg</code>) and organizes them into respective directories. It also generates flowcharts with <code>code2flow</code>.</p> </li> <li> <p>Completion Message: Displays a message confirming successful generation of diagrams.</p> </li> </ul>"},{"location":"pages/dev/scripts/9.diagrams/#usage","title":"Usage","text":"<p>To run the script:</p> <pre><code>./diagrams.sh -m=&lt;module_name&gt; -d=&lt;module_dir&gt; -o=&lt;output_dir&gt;\n</code></pre>"},{"location":"pages/getting-started/","title":"\ud83d\udc24 Getting Started","text":"<p>This section will guide you through the process of setting up the library in your project.</p> <p>For a quick start, follow the steps below.</p>"},{"location":"pages/getting-started/#pages","title":"Pages","text":"<ul> <li>Prerequisites</li> <li>Installation</li> <li>Configuration</li> <li>Examples</li> <li>Error Codes</li> </ul>"},{"location":"pages/getting-started/configuration/","title":"\u2699\ufe0f Configuration","text":""},{"location":"pages/getting-started/configuration/#environment-variables","title":"\ud83c\udf0e Environment Variables","text":"<p><code>.env.example</code>:</p> <pre><code># ENV=development\n# DEBUG=true\n\nONION_CONFIG_EXTRA_DIR=\"./extra_configs\"\n</code></pre>"},{"location":"pages/getting-started/error-codes/","title":"\ud83d\udea8 Error Codes","text":""},{"location":"pages/getting-started/error-codes/#error-handling","title":"Error Handling","text":""},{"location":"pages/getting-started/examples/","title":"\ud83d\udeb8 Examples","text":""},{"location":"pages/getting-started/examples/#simple","title":"Simple","text":"<p><code>examples/simple/.env</code></p> <pre><code>ENV=production\n</code></pre> <p><code>examples/simple/configs/1.base.yml</code>:</p> <pre><code>env: test\n\napp:\n  name: \"My App\"\n  version: \"0.0.1\"\n  nested:\n    key: \"value\"\n</code></pre> <p><code>examples/simple/configs/2.extra.yml</code>:</p> <pre><code>app:\n  name: \"New App\"\n  nested:\n    some: \"value\"\n  description: \"Description of my app.\"\n\nanother_val:\n  extra: 1\n</code></pre> <p><code>examples/simple/main.py</code></p> <pre><code>import pprint\n\nfrom loguru import logger\ntry:\n    import pydantic_settings\n\n    _has_pydantic_settings = True\nexcept ImportError:\n    _has_pydantic_settings = False\n\nfrom onion_config import ConfigLoader, BaseConfig\n\n\nclass ConfigSchema(BaseConfig):\n    env: str = \"local\"\n\ntry:\n    config: ConfigSchema = ConfigLoader(config_schema=ConfigSchema).load()\nexcept Exception:\n    logger.exception(\"Failed to load config:\")\n    exit(2)\n\nif __name__ == \"__main__\":\n    logger.info(f\"All: {config}\")\n    logger.info(f\"App name: {config.app['name']}\")\n\n    if _has_pydantic_settings:\n        # Pydantic-v2:\n        logger.info(f\"Config:\\n{pprint.pformat(config.model_dump())}\\n\")\n    else:\n        # Pydantic-v1:\n        logger.info(f\"Config:\\n{pprint.pformat(config.dict())}\\n\")\n</code></pre> <p>Run the <code>examples/simple</code>:</p> <pre><code>cd ./examples/simple\n\npython ./main.py\n</code></pre> <p>Output:</p> <pre><code>2023-09-01 00:00:00.000 | INFO     | __main__:&lt;module&gt;:29 - All: env='production' another_val={'extra': 1} app={'name': 'New App', 'version': '0.0.1', 'nested': {'key': 'value', 'some': 'value'}, 'description': 'Description of my app.'}\n2023-09-01 00:00:00.000 | INFO     | __main__:&lt;module&gt;:30 - App name: New App\n2023-09-01 00:00:00.000 | INFO     | __main__:&lt;module&gt;:35 - Config:\n{'another_val': {'extra': 1},\n 'app': {'description': 'Description of my app.',\n         'name': 'New App',\n         'nested': {'key': 'value', 'some': 'value'},\n         'version': '0.0.1'},\n 'env': 'production'}\n</code></pre>"},{"location":"pages/getting-started/examples/#advanced","title":"Advanced","text":"<p><code>examples/advanced/.env.base</code>:</p> <pre><code>ENV=development\nDEBUG=true\nAPP_NAME=\"Old App\"\nONION_CONFIG_EXTRA_DIR=\"extra_configs\"\n</code></pre> <p><code>examples/advanced/.env.prod</code>:</p> <pre><code>ENV=production\nAPP_NAME=\"New App\"\nAPP_SECRET=\"my_secret\"\n</code></pre> <p><code>examples/advanced/configs/config.yml</code>:</p> <pre><code>env: local\n\napp:\n  name: \"My App\"\n  port: 9000\n  bind_host: \"0.0.0.0\"\n  version: \"0.0.1\"\n  ignore_val: \"Ignore me\"\n\nlogger:\n  output: \"file\"\n</code></pre> <p><code>examples/advanced/configs/logger.json</code>:</p> <pre><code>{\n    \"logger\": {\n        \"level\": \"info\",\n        \"output\": \"stdout\"\n    }\n}\n</code></pre> <p><code>examples/advanced/configs_2/config.yml</code>:</p> <pre><code>extra:\n  config:\n    key1: 1\n</code></pre> <p><code>examples/advanced/configs_2/config_2.yml</code>:</p> <pre><code>extra:\n  config:\n    key2: 2\n</code></pre> <p><code>examples/advanced/extra_configs/extra.json</code>:</p> <pre><code>{\n    \"extra\": {\n        \"type\": \"json\"\n    }\n}\n</code></pre> <p><code>examples/advanced/schema.py</code>:</p> <pre><code>from enum import Enum\nfrom typing import Union\n\nimport pydantic\nfrom pydantic import Field, SecretStr\n_has_pydantic_settings = False\nif \"2.0.0\" &lt;= pydantic.__version__:\n    try:\n        from pydantic_settings import SettingsConfigDict\n\n        _has_pydantic_settings = True\n    except ImportError:\n        pass\n\nfrom onion_config import BaseConfig\n\n\n# Environments as Enum:\nclass EnvEnum(str, Enum):\n    LOCAL = \"local\"\n    DEVELOPMENT = \"development\"\n    TEST = \"test\"\n    DEMO = \"demo\"\n    STAGING = \"staging\"\n    PRODUCTION = \"production\"\n\n# App config schema:\nclass AppConfig(BaseConfig):\n    name: str = Field(\"App\", min_length=2, max_length=32)\n    bind_host: str = Field(\"localhost\", min_length=2, max_length=128)\n    port: int = Field(8000, ge=80, lt=65536)\n    secret: SecretStr = Field(..., min_length=8, max_length=64)\n    version: str = Field(..., min_length=5, max_length=16)\n    description: Union[str, None] = Field(None, min_length=4, max_length=64)\n\n    if _has_pydantic_settings:\n        # Pydantic-v2:\n        model_config = SettingsConfigDict(extra=\"ignore\", env_prefix=\"APP_\")\n    else:\n        # Pydantic-v1:\n        class Config:\n            extra = \"ignore\"\n            env_prefix = \"APP_\"\n\n# Main config schema:\nclass ConfigSchema(BaseConfig):\n    env: EnvEnum = Field(EnvEnum.LOCAL)\n    debug: bool = Field(False)\n    app: AppConfig = Field(...)\n</code></pre> <p><code>examples/advanced/config.py</code>:</p> <pre><code>from loguru import logger\n\nfrom onion_config import ConfigLoader\n\nfrom schema import ConfigSchema\n\n\n# Pre-load function to modify config data before loading and validation:\ndef _pre_load_hook(config_data: dict) -&gt; dict:\n    config_data[\"app\"][\"port\"] = \"80\"\n    config_data[\"extra_val\"] = \"Something extra!\"\n    return config_data\n\nconfig = None\ntry:\n    _config_loader = ConfigLoader(\n        config_schema=ConfigSchema,\n        configs_dirs=[\"configs\", \"configs_2\", \"/not_exists/path/configs_3\"],\n        env_file_paths=[\".env\", \".env.base\", \".env.prod\"],\n        pre_load_hook=_pre_load_hook,\n        config_data={\"base\": \"start_value\"},\n        warn_mode=\"ALWAYS\",\n    )\n    # Main config object:\n    config: ConfigSchema = _config_loader.load()\nexcept Exception:\n    logger.exception(\"Failed to load config:\")\n    exit(2)\n</code></pre> <p><code>examples/advanced/main.py</code>:</p> <pre><code>import pprint\n\nfrom loguru import logger\ntry:\n    import pydantic_settings\n    _has_pydantic_settings = True\nexcept ImportError:\n    _has_pydantic_settings = False\n\nfrom config import config\n\n\nif __name__ == \"__main__\":\n    logger.info(f\"All: {config}\")\n    logger.info(f\"ENV: {config.env}\")\n    logger.info(f\"DEBUG: {config.debug}\")\n    logger.info(f\"Extra: {config.extra_val}\")\n    logger.info(f\"Logger: {config.logger}\")\n    logger.info(f\"App: {config.app}\")\n    logger.info(f\"Secret: '{config.app.secret.get_secret_value()}'\\n\")\n\n    if _has_pydantic_settings:\n        # Pydantic-v2:\n        logger.info(f\"Config:\\n{pprint.pformat(config.model_dump())}\\n\")\n    else:\n        # Pydantic-v1:\n        logger.info(f\"Config:\\n{pprint.pformat(config.dict())}\\n\")\n\n    try:\n        # This will raise ValidationError\n        config.app.port = 8443\n    except Exception as e:\n        logger.error(f\"{e}\\n\")\n</code></pre> <p>Run the <code>examples/advanced</code>:</p> <pre><code>cd ./examples/advanced\n\npython ./main.py\n</code></pre> <p>Output:</p> <pre><code>2023-09-01 00:00:00.000 | INFO     | onion_config._base:load:143 - Loading all configs...\n2023-09-01 00:00:00.000 | WARNING  | onion_config._base:_load_dotenv_file:201 - '/home/user/workspaces/projects/onion_config/examples/advanced/.env' file is not exist!\n2023-09-01 00:00:00.000 | WARNING  | onion_config._base:_load_configs_dir:257 - '/not_exists/path/configs_3' directory is not exist!\n2023-09-01 00:00:00.000 | SUCCESS  | onion_config._base:load:171 - Successfully loaded all configs!\n2023-09-01 00:00:00.000 | INFO     | __main__:&lt;module&gt;:19 - All: env=&lt;EnvEnum.PRODUCTION: 'production'&gt; debug=True app=AppConfig(name='New App', bind_host='0.0.0.0', port=80, secret=SecretStr('**********'), version='0.0.1', description=None) extra={'config': {'key1': 1, 'key2': 2}, 'type': 'json'} extra_val='Something extra!' logger={'output': 'stdout', 'level': 'info'} base='start_value'\n2023-09-01 00:00:00.000 | INFO     | __main__:&lt;module&gt;:20 - ENV: production\n2023-09-01 00:00:00.000 | INFO     | __main__:&lt;module&gt;:21 - DEBUG: True\n2023-09-01 00:00:00.000 | INFO     | __main__:&lt;module&gt;:22 - Extra: Something extra!\n2023-09-01 00:00:00.000 | INFO     | __main__:&lt;module&gt;:23 - Logger: {'output': 'stdout', 'level': 'info'}\n2023-09-01 00:00:00.000 | INFO     | __main__:&lt;module&gt;:24 - App: name='New App' bind_host='0.0.0.0' port=80 secret=SecretStr('**********') version='0.0.1' description=None\n2023-09-01 00:00:00.000 | INFO     | __main__:&lt;module&gt;:25 - Secret: 'my_secret'\n\n2023-09-01 00:00:00.000 | INFO     | __main__:&lt;module&gt;:30 - Config:\n{'app': {'bind_host': '0.0.0.0',\n         'description': None,\n         'name': 'New App',\n         'port': 80,\n         'secret': SecretStr('**********'),\n         'version': '0.0.1'},\n 'base': 'start_value',\n 'debug': True,\n 'env': &lt;EnvEnum.PRODUCTION: 'production'&gt;,\n 'extra': {'config': {'key1': 1, 'key2': 2}, 'type': 'json'},\n 'extra_val': 'Something extra!',\n 'logger': {'level': 'info', 'output': 'stdout'}}\n\n2023-09-01 00:00:00.000 | ERROR    | __main__:&lt;module&gt;:36 - \"AppConfig\" is immutable and does not support item assignment\n</code></pre>"},{"location":"pages/getting-started/installation/","title":"\ud83d\udee0 Installation","text":""},{"location":"pages/getting-started/installation/#1-download-or-clone-the-repository","title":"1. \ud83d\udce5 Download or clone the repository","text":"<p>[!TIP] Skip this step, if you're going to install the package directly from PyPi or GitHub repository.</p> <p>1.1. Prepare projects directory (if not exists):</p> <pre><code># Create projects directory:\nmkdir -pv ~/workspaces/projects\n\n# Enter into projects directory:\ncd ~/workspaces/projects\n</code></pre> <p>1.2. Follow one of the below options [A], [B] or [C]:</p> <p>OPTION A. Clone the repository:</p> <pre><code>git clone https://github.com/bybatkhuu/module.python-config.git &amp;&amp; \\\n    cd module.python-config\n</code></pre> <p>OPTION B. Clone the repository (for DEVELOPMENT: git + ssh key):</p> <pre><code>git clone git@github.com:bybatkhuu/module.python-config.git &amp;&amp; \\\n    cd module.python-config\n</code></pre> <p>OPTION C. Download source code:</p> <ol> <li>Download archived zip file from releases.</li> <li>Extract it into the projects directory.</li> </ol>"},{"location":"pages/getting-started/installation/#2-install-the-package","title":"2. \ud83d\udce6 Install the package","text":"<p>[!NOTE] Choose one of the following methods to install the package [A ~ E]:</p> <p>OPTION A. [RECOMMENDED] Install from PyPi:</p> <p>[!WARNING] If you wanted to use Pydantic-v1, but if you already installed <code>pydantic-settings</code> and <code>pydantic-core</code>, remove it before installing Pydantic-v1:</p> <pre><code>pip uninstall -y pydantic-settings\npip uninstall -y pydantic-core\n\n# Then install with Pydantic-v1:\npip install -U onion-config[pydantic-v1]\n</code></pre> <p>[!WARNING] If you wanted to use Pydantic-v2, but if you already installed <code>onion-config</code> package just by \\ <code>pip install -U onion-config</code> command, and this will not install <code>pydantic-settings</code>. \\ For this case, '<code>env_prefix</code>' WILL NOT WORK for <code>BaseConfig</code> or <code>BaseSettings</code> without <code>pydantic-settings</code>! This is Pydantic-v2's problem, and there could be some other problems. \\ So fix these issues re-install <code>onion-config</code> with <code>pydantic-settings</code>:</p> <pre><code># Install with pydantic-settings for Pydantic-v2:\npip install -U onion-config[pydantic-settings]\n</code></pre> <p>OPTION B. Install latest version directly from GitHub repository:</p> <pre><code># Pydantic-v1:\npip install git+https://github.com/bybatkhuu/module.python-config.git[pydantic-v1]\n\n# Pydantic-v2:\npip install git+https://github.com/bybatkhuu/module.python-config.git[pydantic-settings]\n</code></pre> <p>OPTION C. Install from the downloaded source code:</p> <pre><code># Install directly from the source code:\n# Pydantic-v1:\npip install .[pydantic-v1]\n# Pydantic-v2:\npip install .[pydantic-settings]\n\n# Or install with editable mode (for DEVELOPMENT):\n# Pydantic-v1:\npip install -e .[pydantic-v1]\n# Pydantic-v2:\npip install -e .[pydantic-settings]\n</code></pre> <p>OPTION D. Install from pre-built release files:</p> <ol> <li>Download <code>.whl</code> or <code>.tar.gz</code> file from releases</li> <li>Install with pip:</li> </ol> <pre><code># Pydantic-v1:\n# Install from .whl file:\npip install ./onion_config-[VERSION]-py3-none-any.whl[pydantic-v1]\n# Or install from .tar.gz file:\npip install ./onion_config-[VERSION].tar.gz[pydantic-v1]\n\n# Pydantic-v2:\n# Install from .whl file:\npip install ./onion_config-[VERSION]-py3-none-any.whl[pydantic-settings]\n# Or install from .tar.gz file:\npip install ./onion_config-[VERSION].tar.gz[pydantic-settings]\n</code></pre> <p>OPTION E. Copy the module into the project directory (for testing):</p> <pre><code># Install python dependencies:\npip install -r ./requirements/requirements.core.txt\n\n# Pydantic-v1:\npip install -r ./requirements/requirements.pydantic-v1.txt\n# Pydantic-v2:\npip install -r ./requirements/requirements.pydantic-settings.txt\n\n# Copy the module source code into the project:\ncp -r ./src/onion_config [PROJECT_DIR]\n# For example:\ncp -r ./src/onion_config /some/path/project/\n</code></pre>"},{"location":"pages/getting-started/prerequisites/","title":"\ud83d\udea7 Prerequisites","text":"<ul> <li>Install Python (&gt;= v3.9) and pip (&gt;= 23):<ul> <li>[RECOMMENDED]  Miniconda (v3)</li> <li>[arm64/aarch64]  Miniforge (v3)</li> <li>[Python virutal environment]  venv</li> </ul> </li> </ul> <p>[OPTIONAL] For DEVELOPMENT environment:</p> <ul> <li>Install git</li> <li>Setup an SSH key (video tutorial)</li> </ul>"}]}